Refactoring to 3-tier architecture:
- move all business logic to server 
    x- bring back file preservation, but do it on the server
    - make different contexts for each functionality (different requestHandler for each)
        x- /loadPrompts
        x- /newQuestion 
        x- /deletePrompt
        x- /clearAll
        - /createEmail
        - /sendEmail
x- make UI only show buttons, and prompts retreived from server
    x- should no longer store anything 
    x- buttons/functionalities should just be: 
        x- making a request (which changes the prompts on the server) 
        x- receving back a string response (used to update the UI)
x- Only App, AppFrame, Footer, and ScrollFrame are needed for UI
x- Rest of the classes should be doing stuff on the server


In loadPromptsHandler (update):
    x- update handlePut() (after making devHandler), that will read in an email and password and check if they're valid:
        x- if they are, do Cristian's reading mango in there to fill prompts (move the restore() in Server into there)
            x- store the email into the StringBuilder email
            x- return "Valid Login" response 
        x- otherwise, return "Invalid Login"
    - also update handlePut() that will read a query
        - if the query says "autoLogin", check if the IP of the computer exists in the database
            - if it does, 
                - store the email associated with that IP into StringBuilder email
                - do Cristian's reading mongo thing to fill prompts
                x- return "Automatic Login"
            x- if it doesn't,
                x- return "No Automatic Login"
    - also update handlePut() that will read a different query
        - if the query says "addLogin", 
            - read from file to get IP and email from request
            - store that email into StringBuilder email
                - create a new User with the IP and email in the Mongo Users collection
                - return "Added AutoLogin"
    x- create handlePost() that will read in an email and password and check if the email already exists:
        x- if it does, return "Email already used"
        x- if it doesn't, 
            x- ask Cristian how to add that email and password as a new entry into mongo
            x- store the email into the StringBuilder email
            x- return "Account Created"
    x- update handleGet() to write the prompts to the database under the email that is currently logged into


In createEmailHandler:
    x- (similar to newQH handlePut()) create a handlePut() method that does the following:
        x- read the email subject from the input file
        x- call makeAnswer() from OutputA to get ChatGPT response
        x- add (the command), the email subject, then the ChatGPT response to prompts
        x- Optional: print - "createEH: " + response
        x- return response (which should be the ChatGPT's answer/reponse from makeAnswer())


In AppFrame:
    Step 1:
    - create a function called "createEmail(String subject)", which will do the following:
        - request handlePut() in createEmailHandler and input (inside a file) the email subject into it 
            - (it is similar to the code in newQuestion())
        - read the server's response from its file (that file should contain the email contents to the email subject made from ChatGPT)
            - (it is similar to how it was done in newQuestion())
        - add the command (Create Email), the email subject, and the response into the scrollFrame
    Step 2:
    - in the same place y'all made the string parsing:
        - parse the response from startHandler to also look for "create email"
            - Ex| response = "create email to Jill let's meet at Geisel for our 7pm study session"
        - call createEmail(String subject) and pass in entirety of response into it
            - Ex| pass in all of "create email to Jill let's meet at Geisel for our 7pm study session", not just "to Jill let's meet at Geisel for our 7pm study session"


In Prompts:
    x- change constructor to also take in a StringBuilder emailPrompt
        x- will store command, query (subject), and response into it
    x- if the command is "Create Email":
        x- create an additional button to be used to select an email
    x- if the email button is pressed:
        x- set emailPrompt that command, query, and response
    x- fix everywehere where a Prompt is created
        x- in handlers, put a null for the 4th parameter
        x- in AppFrame, input emailPrompt


In AppFrame: 
    x- create a StringBuilder emailPrompt 
        x- to contain command, query (subject), and response
    x- whenever a Prompt is created, pass in emailPrompt


Where ever ethan made his changes:
    - request loadPH handlePut() with query = "autoLogin"
        - if the response says "Automatic Login", move on to homepage
        - otherwise if the response says "No Automatic Login",
            x- stay on account login page and call loadPH handlePut() w/o query and input the email and password from user into it
